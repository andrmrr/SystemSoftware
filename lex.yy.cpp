// lex.yy.cpp generated by reflex 3.3.2 from reflex.l

#define REFLEX_VERSION "3.3.2"

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  OPTIONS USED                                                              //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#define REFLEX_OPTION_header_file         "lex.yy.h"
#define REFLEX_OPTION_lex                 lex
#define REFLEX_OPTION_lexer               Lexer
#define REFLEX_OPTION_outfile             "lex.yy.cpp"
#define REFLEX_OPTION_token_type          Token

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %top user code                                                 //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 5 "reflex.l"

  #include <stdio.h>
  #include "tokens.h"


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  REGEX MATCHER                                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/matcher.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  ABSTRACT LEXER CLASS                                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/abslexer.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  LEXER CLASS                                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

class Lexer : public reflex::AbstractLexer<reflex::Matcher> {
#line 10 "reflex.l"



 public:
  typedef reflex::AbstractLexer<reflex::Matcher> AbstractBaseLexer;
  Lexer(
      // a persistent source of input, empty by default
      const reflex::Input& input = reflex::Input(),
      // optional output stream, std::cout by default
      std::ostream& os = std::cout)
    :
      AbstractBaseLexer(input, os)
  {
  }
  static const int INITIAL = 0;
  static const int COMMENT = 1;
  static const int DIR = 2;
  static const int STRING = 3;
  // the lexer function defined by SECTION 2
  virtual Token lex(void);
  // lexer functions accepting new input to scan
  Token lex(const reflex::Input& input)
  {
    in(input);
    return lex();
  }
  Token lex(const reflex::Input& input, std::ostream *os)
  {
    in(input);
    if (os)
      out(*os);
    return lex();
  }
};

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 2: rules                                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

Token Lexer::lex(void)
{
  static const char *REGEX_INITIAL = "(?m)((?:\\Q#\\E))|((?:\\Q\"\\E))|([\\x09\\x0d\\x20])|((?:\\Q.\\E))|((?:\\Qhalt\\E))|((?:\\Qint\\E))|((?:\\Qiret\\E))|((?:\\Qcall\\E))|((?:\\Qret\\E))|((?:\\Qjmp\\E))|((?:\\Qbeq\\E))|((?:\\Qbne\\E))|((?:\\Qbgt\\E))|((?:\\Qpush\\E))|((?:\\Qpop\\E))|((?:\\Qxchg\\E))|((?:\\Qadd\\E))|((?:\\Qsub\\E))|((?:\\Qmul\\E))|((?:\\Qdiv\\E))|((?:\\Qnot\\E))|((?:\\Qand\\E))|((?:\\Qor\\E))|((?:\\Qxor\\E))|((?:\\Qshl\\E))|((?:\\Qshr\\E))|((?:\\Qld\\E))|((?:\\Qst\\E))|((?:\\Qcsrrd\\E))|((?:\\Qcsrwr\\E))|((?:[A-Za-z])(?:(?:[A-Za-z])|(?:[0-9])|_)*)|((?:[A-Za-z])(?:(?:[A-Za-z])|(?:[0-9])|_)*(?:\\Q:\\E))|((?:\\Q$\\E)(?:[A-Za-z])(?:(?:[A-Za-z])|(?:[0-9]))*)|(0x(?:[0-9A-Fa-f])+)|((?:[0-9])+)|((?:\\Q$\\E)0x(?:[0-9A-Fa-f])+)|((?:\\Q$\\E)(?:[0-9])+)|((?:\\Q%\\E)status)|((?:\\Q%\\E)handler)|((?:\\Q%\\E)cause)|((?:\\Q%\\E)r(?:[0-9]))|((?:\\Q%\\E)r1[0-5])|((?:\\Q%\\E)sp)|((?:\\Q%\\E)pc)|((?:\\Q[\\E))|((?:\\Q]\\E))|((?:\\Q,\\E))|((?:\\Q:\\E))|((?:\\Q+\\E))|((?:\\Q-\\E))|(\\n)|(.)";
  static const reflex::Pattern PATTERN_INITIAL(REGEX_INITIAL);
  static const char *REGEX_COMMENT = "(?m)(.)|(\\n)";
  static const reflex::Pattern PATTERN_COMMENT(REGEX_COMMENT);
  static const char *REGEX_DIR = "(?m)((?:\\Qglobal\\E))|((?:\\Qextern\\E))|((?:\\Qsection\\E))|((?:\\Qword\\E))|((?:\\Qskip\\E))|((?:\\Qascii\\E))|((?:\\Qequ\\E))|((?:\\Qend\\E))";
  static const reflex::Pattern PATTERN_DIR(REGEX_DIR);
  static const char *REGEX_STRING = "(?m)([^\\x0a\"]+)|((?:\\Q\"\\E))|(\\n)";
  static const reflex::Pattern PATTERN_STRING(REGEX_STRING);
  if (!has_matcher())
  {
    matcher(new Matcher(PATTERN_INITIAL, stdinit(), this));
  }
  while (true)
  {
    switch (start())
    {
      case INITIAL:
        matcher().pattern(PATTERN_INITIAL);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              return Token();
            }
            else
            {
              out().put(matcher().input());
            }
            break;
          case 1: // rule reflex.l:26: "#" :
#line 26 "reflex.l"
{start(COMMENT);}
            break;
          case 2: // rule reflex.l:30: "\"" :
#line 30 "reflex.l"
{start(STRING);}
            break;
          case 3: // rule reflex.l:35: [ \t\r] :
#line 35 "reflex.l"
{}


            break;
          case 4: // rule reflex.l:38: "." :
#line 38 "reflex.l"
{start(DIR);}
            break;
          case 5: // rule reflex.l:49: "halt" :
#line 49 "reflex.l"
{return Token(TokenType::HALT, str());}
            break;
          case 6: // rule reflex.l:50: "int" :
#line 50 "reflex.l"
{return Token(TokenType::INT, str());}
            break;
          case 7: // rule reflex.l:51: "iret" :
#line 51 "reflex.l"
{return Token(TokenType::IRET, str());}
            break;
          case 8: // rule reflex.l:52: "call" :
#line 52 "reflex.l"
{return Token(TokenType::CALL, str());}
            break;
          case 9: // rule reflex.l:53: "ret" :
#line 53 "reflex.l"
{return Token(TokenType::RET, str());}
            break;
          case 10: // rule reflex.l:54: "jmp" :
#line 54 "reflex.l"
{return Token(TokenType::JMP, str());}
            break;
          case 11: // rule reflex.l:55: "beq" :
#line 55 "reflex.l"
{return Token(TokenType::BEQ, str());}
            break;
          case 12: // rule reflex.l:56: "bne" :
#line 56 "reflex.l"
{return Token(TokenType::BNE, str());}
            break;
          case 13: // rule reflex.l:57: "bgt" :
#line 57 "reflex.l"
{return Token(TokenType::BGT, str());}
            break;
          case 14: // rule reflex.l:58: "push" :
#line 58 "reflex.l"
{return Token(TokenType::PUSH, str());}
            break;
          case 15: // rule reflex.l:59: "pop" :
#line 59 "reflex.l"
{return Token(TokenType::POP, str());}
            break;
          case 16: // rule reflex.l:60: "xchg" :
#line 60 "reflex.l"
{return Token(TokenType::XCHG, str());}
            break;
          case 17: // rule reflex.l:61: "add" :
#line 61 "reflex.l"
{return Token(TokenType::ADD, str());}
            break;
          case 18: // rule reflex.l:62: "sub" :
#line 62 "reflex.l"
{return Token(TokenType::SUB, str());}
            break;
          case 19: // rule reflex.l:63: "mul" :
#line 63 "reflex.l"
{return Token(TokenType::MUL, str());}
            break;
          case 20: // rule reflex.l:64: "div" :
#line 64 "reflex.l"
{return Token(TokenType::DIV, str());}
            break;
          case 21: // rule reflex.l:65: "not" :
#line 65 "reflex.l"
{return Token(TokenType::NOT, str());}
            break;
          case 22: // rule reflex.l:66: "and" :
#line 66 "reflex.l"
{return Token(TokenType::AND, str());}
            break;
          case 23: // rule reflex.l:67: "or" :
#line 67 "reflex.l"
{return Token(TokenType::OR, str());}
            break;
          case 24: // rule reflex.l:68: "xor" :
#line 68 "reflex.l"
{return Token(TokenType::XOR, str());}
            break;
          case 25: // rule reflex.l:69: "shl" :
#line 69 "reflex.l"
{return Token(TokenType::SHL, str());}
            break;
          case 26: // rule reflex.l:70: "shr" :
#line 70 "reflex.l"
{return Token(TokenType::SHR, str());}
            break;
          case 27: // rule reflex.l:71: "ld" :
#line 71 "reflex.l"
{return Token(TokenType::LD, str());}
            break;
          case 28: // rule reflex.l:72: "st" :
#line 72 "reflex.l"
{return Token(TokenType::ST, str());}
            break;
          case 29: // rule reflex.l:73: "csrrd" :
#line 73 "reflex.l"
{return Token(TokenType::CSRRD, str());}
            break;
          case 30: // rule reflex.l:74: "csrwr" :
#line 74 "reflex.l"
{return Token(TokenType::CSRWR, str());}


            break;
          case 31: // rule reflex.l:77: {letter}({letter}|{digit}|_)* :
#line 77 "reflex.l"
{return Token(TokenType::IDENT, str());}
            break;
          case 32: // rule reflex.l:78: {letter}({letter}|{digit}|_)*":" :
#line 78 "reflex.l"
{return Token(TokenType::LABEL, str());}
            break;
          case 33: // rule reflex.l:79: "$"{letter}({letter}|{digit})* :
#line 79 "reflex.l"
{return Token(TokenType::SYM_CONST, str());}
            break;
          case 34: // rule reflex.l:80: 0x{hex_digit}+ :
#line 80 "reflex.l"
{return Token(TokenType::HEX, str());}
            break;
          case 35: // rule reflex.l:81: {digit}+ :
#line 81 "reflex.l"
{return Token(TokenType::DEC, str());}
            break;
          case 36: // rule reflex.l:82: "$"0x{hex_digit}+ :
#line 82 "reflex.l"
{return Token(TokenType::LIT_HEX, str());}
            break;
          case 37: // rule reflex.l:83: "$"{digit}+ :
#line 83 "reflex.l"
{return Token(TokenType::LIT_DEC, str());}
            break;
          case 38: // rule reflex.l:84: "%"status :
#line 84 "reflex.l"
{return Token(TokenType::STATUS, str());}
            break;
          case 39: // rule reflex.l:85: "%"handler :
#line 85 "reflex.l"
{return Token(TokenType::HANDLER, str());}
            break;
          case 40: // rule reflex.l:86: "%"cause :
#line 86 "reflex.l"
{return Token(TokenType::CAUSE, str());}
            break;
          case 41: // rule reflex.l:87: "%"r{digit} :
#line 87 "reflex.l"
{return Token(TokenType::GPR, str());}
            break;
          case 42: // rule reflex.l:88: "%"r1[0-5] :
#line 88 "reflex.l"
{return Token(TokenType::GPR, str());}
            break;
          case 43: // rule reflex.l:89: "%"sp :
#line 89 "reflex.l"
{return Token(TokenType::GPR, str());}
            break;
          case 44: // rule reflex.l:90: "%"pc :
#line 90 "reflex.l"
{return Token(TokenType::GPR, str());}
            break;
          case 45: // rule reflex.l:91: "[" :
#line 91 "reflex.l"
{return Token(TokenType::BR_OPEN, str());}
            break;
          case 46: // rule reflex.l:92: "]" :
#line 92 "reflex.l"
{return Token(TokenType::BR_CLOSE, str());}
            break;
          case 47: // rule reflex.l:93: "," :
#line 93 "reflex.l"
{return Token(TokenType::COMMA, str());}
            break;
          case 48: // rule reflex.l:94: ":" :
#line 94 "reflex.l"
{return Token(TokenType::COLON, str());}
            break;
          case 49: // rule reflex.l:95: "+" :
#line 95 "reflex.l"
{return Token(TokenType::PLUS, str());}
            break;
          case 50: // rule reflex.l:96: "-" :
#line 96 "reflex.l"
{return Token(TokenType::MINUS, str());}
            break;
          case 51: // rule reflex.l:97: \n :
#line 97 "reflex.l"
{return Token(TokenType::EOL, str());}

            break;
          case 52: // rule reflex.l:99: . :
#line 99 "reflex.l"
{return Token(TokenType::ERROR, str());}


            break;
        }
        break;
      case COMMENT:
        matcher().pattern(PATTERN_COMMENT);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              return Token();
            }
            else
            {
              out().put(matcher().input());
            }
            break;
          case 1: // rule reflex.l:27: . :
#line 27 "reflex.l"
{}
            break;
          case 2: // rule reflex.l:28: \n :
#line 28 "reflex.l"
{start(INITIAL); return Token(TokenType::EOL, str());}

            break;
        }
        break;
      case DIR:
        matcher().pattern(PATTERN_DIR);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              return Token();
            }
            else
            {
              out().put(matcher().input());
            }
            break;
          case 1: // rule reflex.l:39: "global" :
#line 39 "reflex.l"
{start(INITIAL); return Token(TokenType::GLOBAL, str());}
            break;
          case 2: // rule reflex.l:40: "extern" :
#line 40 "reflex.l"
{start(INITIAL); return Token(TokenType::EXTERN, str());}
            break;
          case 3: // rule reflex.l:41: "section" :
#line 41 "reflex.l"
{start(INITIAL); return Token(TokenType::SECTION, str());}
            break;
          case 4: // rule reflex.l:42: "word" :
#line 42 "reflex.l"
{start(INITIAL); return Token(TokenType::WORD, str());}
            break;
          case 5: // rule reflex.l:43: "skip" :
#line 43 "reflex.l"
{start(INITIAL); return Token(TokenType::SKIP, str());}
            break;
          case 6: // rule reflex.l:44: "ascii" :
#line 44 "reflex.l"
{start(INITIAL); return Token(TokenType::ASCII, str());}
            break;
          case 7: // rule reflex.l:45: "equ" :
#line 45 "reflex.l"
{start(INITIAL); return Token(TokenType::EQU, str());}
            break;
          case 8: // rule reflex.l:46: "end" :
#line 46 "reflex.l"
{start(INITIAL); return Token(TokenType::END, str());}


            break;
        }
        break;
      case STRING:
        matcher().pattern(PATTERN_STRING);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              return Token();
            }
            else
            {
              out().put(matcher().input());
            }
            break;
          case 1: // rule reflex.l:31: [^"\n]+ :
#line 31 "reflex.l"
{return Token(TokenType::STRING, str());}
            break;
          case 2: // rule reflex.l:32: "\"" :
#line 32 "reflex.l"
{start(INITIAL);}
            break;
          case 3: // rule reflex.l:33: \n :
#line 33 "reflex.l"
{start(INITIAL); return Token(TokenType::ERROR, str());}

            break;
        }
        break;
      default:
        start(0);
    }
  }
}
